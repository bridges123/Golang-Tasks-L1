1. Какой самый эффективный способ конкатенации строк?
    * Самый эффективный способ конкатенации строк - strings.Builder,
      т.к. по сравнению с оператором +, он аллоцирует память под строку только при вызове метода Grow()
2. Что такое интерфейсы, как они применяются в Go?
    * Интерфейсы определяют некоторый функционал (набор функций), который может реализовать другой тип (структур и т.д)
    * Интерфейсы в Go позволяют определить набор функций, которые структура или другой тип данных может реализовать
      путем
      определения методов с такой же сигнатурой (набором параметров и возвращаемым типом)
    * Также интерфейсы в Go можно встраивать друг в друга
    * Интерфейсы в Go являются общим типом для всех других типов данных (как Object в Java)
3. Чем отличаются RWMutex от Mutex?
    * RWMutex позволяет параллельно читать данные, но не записывать
    * когда вызывается Lock(), до вызова Unlock() блокируются все остальные использования данных
    * когда вызывается RLock(), блокируются только вызовы Lock() на запись, остальные вызовы RLock() на чтение также
      остаются доступными
4. Чем отличаются буферизированные и не буферизированные каналы?
    * Не буферизированные каналы позволяют передавать данные в неограниченном количестве
    * Буферизированные каналы, в отличие от не буферизированных, имею максимальную вместимость.
    * Когда канал заполняется, следующая передача элемента в канал ожидает пока он освободится
    * После закрытия любого канала нельзя добавить в него данные, а оставшиеся данные считываются до опустошения канала
5. Какой размер у структуры struct{}{}?
    * Данная структура будет иметь размер 0 байт, т.к. не содержит полей любых весомых типов
6. Есть ли в Go перегрузка методов или операторов?
    * Фактически, в Go отсутствует возможность перегрузки методов и операторов, т.к. разработчики посчитали, что это
      излишне-необязательный функционал
    * В Go принято разделять перегрузки методов по названиям. Например:
        * WriteByte(c byte)
        * WriteString(s string)
        * WriteRune(r rune)
7. В какой последовательности будут выведены элементы map[int]int? \
   Пример: \
   m[0]=1 \
   m[1]=124 \
   m[2]=281
    * Если использовать range для прохода по парам ключей-значений мапы, то вывод будет в произвольном порядке,
      т.к. map - неупорядоченная структура данных 
    * Print выведет в порядке возрастания ключей
8. В чем разница make и new?
    * new создает в куче объект и возвращает указатель на него.
    * make выделяет память в куче и инициализирует только объекты типов: slice, map, chan.
9. Сколько существует способов задать переменную типа slice или map?
    * Существует 4 способа:
        * var m map[int]int
        * m := map[int]int{}
        * m := make(map[int]int)
        * m := new(map[int]int)
    * Однако при использовании new, map будет оставаться неинициализированным
    * Так же все обстоит со slice, при использовании new - будет неинициализирован
    * При использовании make нужно указывать размер слайса (можно также вместимость)
    * s := make([]int, 3, 6)
10. Что выведет данная программа и почему? \
    * func update(p *int) {
        * b := 2
        * p = &b
    * }

    * func main() {
        * var (
            * a = 1
            * p = &a
        * )
        * fmt.Println(*p)
        * update(p)
        * fmt.Println(*p)
    * }
    * Программа выведет сначала значение указателя p(1), затем попытается присвоить новое значение переменной указателя,
      но т.к. внутри функции изменяется сама переменная, а не значение указателя, снаружи она не изменится.
      Вывод: 1 1
11. Что выведет данная программа и почему?
    * func main() {
        * wg := sync.WaitGroup{}
        * for i := 0; i < 5; i++ {
        * wg.Add(1)
            * go func(wg sync.WaitGroup, i int) {
                * fmt.Println(i)
                * wg.Done()
            * }(wg, i)
        * }
        * wg.Wait()
        * fmt.Println("exit")
    * }
    * Код должен выполнять параллельный вывод чисел, ожидая в конце завершения горутин и вывести exit.
      Однако, т.к. в горутину WaitGroup передается не по указателю, wg.Done() внутри не изменяет кол-во ожидаемых горутин
    * Вследствие чего выйдет ошибка deadlock
12. Что выведет данная программа и почему?
    * func main() {
        * n := 0
        * if true {
            * n := 1
            * n++
        * }
        * fmt.Println(n)
    * }
    * Программа выведет 0, т.к. внутри if мы не изменяем значение переменной n из main,
      мы объявляем и инициализируем новую переменную, локальную для if
13. Что выведет данная программа и почему?
    * func someAction(v []int8, b int8) {
      * v[0] = 100
      v = append(v, b)
    * }
    * 
    * func main() {
      * var a = []int8{1, 2, 3, 4, 5}
      * someAction(a, 6)
      * fmt.Println(a)
    * }
    * Программа выведет слайс [100 2 3 4 5], т.к. слайс передается в функцию как переменная, 
      но 1 элемент слайса ссылается на его массив. Соответственно элементы слайса изменяются "по ссылке",
      внутри других функций, а сама переменная слайса не является указателем, 
      поэтому присвоение append не будет применено во внешней области видимости
14. Что выведет данная программа и почему?
    * func main() {
      * slice := []string{"a", "a"}
      * func(slice []string) {
        * slice = append(slice, "a")
        * slice[0] = "b"
        * slice[1] = "b"
        * fmt.Print(slice)
      * }(slice)
      * fmt.Print(slice)
    * }
    * Т.к. мы присвоили в переменную slice новый объект в памяти(т.к. cap = len), внутри анонимной функции
      переопределено значение slice, также заменив у нового slice 0 и 1 индексы. Первый вывод будет - [b b a].
    * Но Т.к. мы изменили 0 и 1 индексы нового объекта слайса, извне изначальный slice мы не меняли. 
      Поэтому второй вывод - [a a] 